Why clicking Calendar boots you back toâ€¯Login
Calendar â†’ /api/capitalâ€‘calls hits requireAuth
Capitalâ€¯Calls is the only Calendar API that is guarded by requireAuth (see server/routes/capitalâ€‘calls.ts).

requireAuth looks for req.session.userId.
On this request the session object is suddenly empty, so it throws aâ€¯401.
Your <ProtectedRoute> sees user === null and redirects to /login, which feels like a â€œlogoutâ€.

The session vanished because the server silently switched session stores between requests.

In server/index.ts you wrap every request with

ts
Copy
Edit
session({
  store: getSessionStore(),   // ğŸ‘ˆ dynamic
  /* â€¦ */
})
getSessionStore() returns PgSession or the inâ€‘memory MemoryStore dynamically, based on two heuristics:

ts
Copy
Edit
if (hybridStorage.usingDatabase === false) {
  activeSessionStore = memoryStore;   // â† swap midâ€‘flight
}
When the page first loads, the login request is handled while activeSessionStore is a PostgreSQL store (or viceâ€‘versa).
Later, when Calendar makes its first authenticated call, the healthâ€‘check logic decides the DB looks down (or usingDatabase is false) and flips activeSessionStore to MemoryStore.
The old session row obviously isnâ€™t in the new store, so requireAuth fails â‡’ 401 â‡’ redirect.

Any route that doesnâ€™t call requireAuth (Dashboard, Pipeline, etc.) never notices the missing session, so the bug feels specific to Calendar.

ğŸ› ï¸â€¯Fast fix
Stop hotâ€‘swapping the session store.
Pick one store at startup and stick with it for the life of the process.

ts
Copy
Edit
// server/index.ts
// (1) decide once, at boot
const useMemoryOnly =
  process.env.USE_MEMORY_SESSIONS === "true" || process.env.NODE_ENV !== "production";

const sessionStore = useMemoryOnly
  ? new MemoryStore({ checkPeriod: 86400000 })
  : new PgSession({
      pool,
      tableName: "session",
      createTableIfMissing: true,
    });

// (2) one middleware, no switching
app.use(
  session({
    store: sessionStore,
    secret: process.env.SESSION_SECRET || "investment-tracker-secret",
    name: "investment_tracker.sid",
    resave: false,
    saveUninitialized: false,
    rolling: true,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      maxAge: 7 * 24 * 60 * 60 * 1000,
      sameSite: "lax",
      httpOnly: true,
      path: "/",
    },
  }),
);
ğŸ§‘â€ğŸ’»â€¯What else to clean up
Area	Suggestion
Health checks	Keep the DBâ€‘liveness probe, but log and meter it instead of changing session backâ€‘ends on the fly.
Auth routes	If you really need autoâ€‘fallback, replicate the session row into both stores instead of switching stores (complex) or issue a transparent reâ€‘login token.
API consistency	Either: (a) make all routes public and rely on RBAC at the component level, or keep them private and remove dynamic store swapping. Mixing the two surfaces bugs like this quickly.
Client navigation	Replace plain <a href="/calendar"> with Wouterâ€™s <Link> to avoid fullâ€‘page reloads (not the root cause here, but better UX).

âœ…â€¯Test it in Replit
Remove the dynamic getSessionStore logic (or hardâ€‘code MemoryStore while youâ€™re on Replit).

pnpm dev â†’ log in â†’ click Calendar: you should stay authenticated.

Optional: add a Jest/supertest integration test that logs in, flips routes, and asserts 200, guarding against regressions.

Let me know if youâ€™d like a patch diff or help wiring a quick test!